
==================== FINAL INTERFACE ====================
2016-03-01 11:43:30.845641 UTC

interface main:Codec.Percent 7084
  interface hash: 7f7d914638f6238edbce6e0947049c62
  ABI hash: 67913536c8c7207add169910fd7812c7
  export-list hash: b2e8e41ca59a8154bdccb6995bcd9c4b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7749715f4e0059100fbc4e9cca5998c7
  used TH splices: False
  where
exports:
  Codec.Percent.getDecodedChar
  Codec.Percent.getDecodedString
  Codec.Percent.getEncodedChar
  Codec.Percent.getEncodedString
module dependencies:
package dependencies: base* ghc-prim integer-gmp
orphans: base:GHC.Base base:GHC.Float base:GHC.Real
family instance modules: base:Data.Either base:Data.Monoid
                         base:Data.Type.Equality base:GHC.Generics
import  -/  base:Data.Char 1ace810ea04187cd227c9ed982bb7d15
import  -/  base:Data.Maybe 5034d40e23c3a7110309f188001df4ca
import  -/  base:GHC.Base 5d7c5f596f9a4c8a8abd8517c8bcd5dd
import  -/  base:GHC.Char 5e706659b769bf2b67d6f91e542a21e9
import  -/  base:GHC.Enum 21572a7ecadc01c858f3321ea577e161
import  -/  base:GHC.List 4cff382327e59a5787355ca0a4174450
import  -/  base:GHC.Real 35345ccdfd774068d1f4418df87bd3c9
import  -/  base:GHC.Unicode 328b8e1d86fa0b0f8b798c018561e9b0
import  -/  base:Numeric fd38becb40ff3d01df4ca3af1a1cc583
import  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
import  -/  ghc-prim:GHC.Classes 3e6cbe1e7e80480408cfa8d5450726a0
ed31e925e7dc8856d8b652b6bb10b0a6
  $wgetEncodedChar :: GHC.Prim.Char#
                      -> Data.Maybe.Maybe GHC.Base.String
    {- Arity: 1, Strictness: <L,U>,
       Unfolding: (\ ww :: GHC.Prim.Char# ->
                   case {__pkg_ccall base u_iswalnum GHC.Prim.Int#
                                                     -> GHC.Prim.State# GHC.Prim.RealWorld
                                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                           GHC.Prim.Int# #)}
                          (GHC.Prim.narrow32Int# (GHC.Prim.ord# ww))
                          GHC.Prim.realWorld# of wild1 { (#,#) ds ds1 ->
                   let {
                     $j :: GHC.Prim.Void# -> Data.Maybe.Maybe GHC.Base.String
                       {- Arity: 1, Strictness: <L,A> -}
                     = \ w :: GHC.Prim.Void# ->
                       let {
                         a :: GHC.Prim.Int# = GHC.Prim.ord# ww
                       } in
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<# a 255) of wild {
                         GHC.Types.False -> Codec.Percent.getEncodedChar3
                         GHC.Types.True
                         -> Data.Maybe.Just
                              @ GHC.Base.String
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 Codec.Percent.getEncodedChar2
                                 (Numeric.$wshowIntAtBase
                                    @ GHC.Types.Int
                                    GHC.Num.$fNumInt
                                    GHC.Classes.$fOrdInt
                                    GHC.Real.$fEnumRatio_$ctoRational
                                    GHC.Real.$fIntegralInt_$cquotRem
                                    GHC.Real.$fIntegralInt_$ctoInteger
                                    GHC.Show.$fShowInt
                                    Codec.Percent.getDecodedChar1
                                    GHC.Show.intToDigit
                                    (case GHC.Classes.divInt# a 16 of ww4 { DEFAULT ->
                                     GHC.Types.I# ww4 })
                                    (Numeric.$wshowIntAtBase
                                       @ GHC.Types.Int
                                       GHC.Num.$fNumInt
                                       GHC.Classes.$fOrdInt
                                       GHC.Real.$fEnumRatio_$ctoRational
                                       GHC.Real.$fIntegralInt_$cquotRem
                                       GHC.Real.$fIntegralInt_$ctoInteger
                                       GHC.Show.$fShowInt
                                       Codec.Percent.getDecodedChar1
                                       GHC.Show.intToDigit
                                       (case GHC.Classes.modInt# a 16 of ww2 { DEFAULT ->
                                        GHC.Types.I# ww2 })
                                       (GHC.Types.[] @ GHC.Types.Char)))) }
                   } in
                   case GHC.Prim.narrow32Int# ds1 of wild2 {
                     DEFAULT
                     -> case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.ltChar# ww '\128') of wild {
                          GHC.Types.False
                          -> case GHC.List.elem
                                    @ GHC.Types.Char
                                    GHC.Classes.$fEqChar
                                    (GHC.Types.C# ww)
                                    Codec.Percent.getEncodedChar1 of wild3 {
                               GHC.Types.False -> $j GHC.Prim.void#
                               GHC.Types.True -> Data.Maybe.Nothing @ GHC.Base.String }
                          GHC.Types.True -> Data.Maybe.Nothing @ GHC.Base.String }
                     0
                     -> case GHC.List.elem
                               @ GHC.Types.Char
                               GHC.Classes.$fEqChar
                               (GHC.Types.C# ww)
                               Codec.Percent.getEncodedChar1 of wild {
                          GHC.Types.False -> $j GHC.Prim.void#
                          GHC.Types.True -> Data.Maybe.Nothing @ GHC.Base.String } } }) -}
919aca9a9208621c8c60ee6b2fd393dc
  getDecodedChar :: GHC.Base.String
                    -> Data.Maybe.Maybe (GHC.Types.Char, GHC.Base.String)
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ str :: GHC.Base.String ->
                   case str of wild {
                     [] -> Data.Maybe.Nothing @ (GHC.Types.Char, GHC.Base.String)
                     : x xs
                     -> case x of wild1 { GHC.Types.C# c1 ->
                        case c1 of wild2 {
                          DEFAULT -> Data.Maybe.Nothing @ (GHC.Types.Char, GHC.Base.String)
                          '%'
                          -> case xs of wild3 {
                               [] -> Data.Maybe.Nothing @ (GHC.Types.Char, GHC.Base.String)
                               : b1 ds
                               -> case ds of wild4 {
                                    [] -> Data.Maybe.Nothing @ (GHC.Types.Char, GHC.Base.String)
                                    : b2 bs
                                    -> case Text.Read.Lex.$wa2
                                              @ GHC.Types.Int
                                              GHC.Classes.$fEqInt
                                              GHC.Num.$fNumInt
                                              Codec.Percent.getDecodedChar1
                                              @ GHC.Types.Int
                                              (Text.ParserCombinators.ReadP.$fMonadP_$creturn
                                                 @ GHC.Types.Int) of ww { (##) ww1 ->
                                       case Text.ParserCombinators.ReadP.readP_to_S_$srun
                                              @ GHC.Types.Int
                                              ww1
                                              (GHC.Types.:
                                                 @ GHC.Types.Char
                                                 b1
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    b2
                                                    (GHC.Types.[] @ GHC.Types.Char))) of wild5 {
                                         []
                                         -> Data.Maybe.Nothing @ (GHC.Types.Char, GHC.Base.String)
                                         : ds1 ds2
                                         -> case ds1 of wild6 { (,) v ds3 ->
                                            Data.Maybe.Just
                                              @ (GHC.Types.Char, GHC.Base.String)
                                              (GHC.Char.chr v, bs) } } } } } } } }) -}
41bdf669688fbda7b6fd7d1ff00848f7
  getDecodedChar1 :: GHC.Types.Int
    {- HasNoCafRefs, Unfolding: (GHC.Types.I# 16) -}
a31c2aaad8c41e0d76398c490362c4a1
  getDecodedString :: GHC.Base.String -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U> -}
dfa34ffa5f5fd66cfb2d5bac92dc9b8d
  getEncodedChar :: GHC.Types.Char
                    -> Data.Maybe.Maybe GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: GHC.Types.Char ->
                   case w of ww { GHC.Types.C# ww1 ->
                   Codec.Percent.$wgetEncodedChar ww1 }) -}
8ef158dd0b86a76e19acf7b2c08e10c6
  getEncodedChar1 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString# "-_.~"#) -}
d2f56386f9da3b349cfbd998eeaa96f6
  getEncodedChar2 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '%') -}
00b5d6e2d5dd00ce4e22e0f9c50607f1
  getEncodedChar3 :: Data.Maybe.Maybe GHC.Base.String
    {- Strictness: b -}
5e8752d76273a451793f74526045f04e
  getEncodedString :: GHC.Base.String -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe-inferred
require own pkg trusted: False

